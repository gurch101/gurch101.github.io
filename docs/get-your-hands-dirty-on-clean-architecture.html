<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Get your Hands Dirty On Clean Architecture | Gurchet&#x27;s Development Blog</title><meta name="description" content="Get Your Hands Dirty on Clean Architecture Summary"/><link rel="icon" href="/favicon.ico"/><meta name="next-head-count" content="5"/><link rel="preload" href="/_next/static/css/549468e6bf83b511.css" as="style"/><link rel="stylesheet" href="/_next/static/css/549468e6bf83b511.css" data-n-g=""/><link rel="preload" href="/_next/static/css/4634d28b7f97c8b5.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4634d28b7f97c8b5.css" data-n-p=""/><noscript data-n-css=""></noscript></head><body><div id="__next"><div class="container"><div><h1 class="mb3">Get your Hands Dirty On Clean Architecture</h1><div class="meta"><span>Sat Oct 09 2021</span><span>book summary</span></div><div class="mt25 post"><h3>What's Wrong with Layers</h3>
<p>Traditional app - controllers, domain/service, persistence</p>
<p>Problems:</p>
<ul>
<li>It promotes database-driven design. We should be trying to model behaviour, not state. Also leads to tight coupling between the repository/entities and the service.</li>
<li>It's prone to shortcuts. In a typical layered architecture, you can only access things in the same layer or lower. If you need to access something in a higher layer, we move the thing to the lower layer. IE utils/helpers in repo layer.</li>
<li>It grows hard to test. In simple cases, devs make the controller talk to repo directly - makes test setup difficult. More dependencies = harder test setup. A complex test setup is the first step towards no tests at all because we don't have time for them.</li>
<li>It hides the use cases. Layered architectures don't impose rules on the "width" of domain services making things hard to find/maintain.</li>
<li>It makes parallel work difficult.</li>
</ul>
<h3>Inverting Dependencies</h3>
<p>Single Responsibility Principle - a component should only have one reason to change.</p>
<p>You shouldn't need to change a component if its dependencies change.</p>
<p>Dependency inversion principle - invert the direction of any dependency in our code base.</p>
<p>The domain code shouldn't have dependencies; instead, all depdencies point towards the domain code.</p>
<p><img src="/images/di.png" alt="Dependency Inversion">
<img src="/images/hexarch.png" alt="Hexagonal Architecture"></p>
<h3>Organizing Code</h3>
<p>Traditional package structure is just a nice-looking facade for an unstructured mess of code - classes in one package import classes from other packages that should not be imported.</p>
<div class="remark-highlight"><pre class="language-unknown"><code class="language-unknown">app
    /domain
    /persistence
    /web</code></pre></div>
<p>Organizing by feature - allows enforcing access via package-private visibility for classes. Don't allow broad services (ie use SendMoneyService vs AccountService).</p>
<div class="remark-highlight"><pre class="language-unknown"><code class="language-unknown">app
    /feature1
        /adapter
            /in
                /web
            /out
                /persistence
        /domain
            Account
        /application
            SendMoneyService
            GetAccountBalanceService
            /port
                /in
                    SendMoneyUseCase
                    SendMoneyCommand
                    GetAccountBalanceQuery
                /out
                    LoadAccountPort
    /feature2</code></pre></div>
<p><img src="/images/hexarchpackages.png" alt="Package structure"></p>
<h3>Implementing a Use Case</h3>
<ul>
<li>don't put input validation in input adapters since multiple adapters may consume use case. Instead, put validation in the input model. Each use case should have a dedicated input model.</li>
<li>business rule validation should go in the domain entities (rich domain model) or in the use case code itself (anemic domain model).</li>
<li>use cases should return as little data as possible. Return types should be isolated from other use cases.</li>
</ul>
<p><img src="/images/usecase.png" alt="Use Case"></p>
<h3>Implementing a Web Adapter</h3>
<p>Web adapters take requests from the outside and translates them into calls to our application core. Control flow goes from controllers in the web adapter to the services in the app layer.</p>
<p><img src="/images/webadapter.png" alt="Web Adapter"></p>
<p>Responsibilities:</p>
<ul>
<li>Map HTTP request to native objects</li>
<li>Perform auth checks</li>
<li>Validate input (ensure input model can be translated to use case model)</li>
<li>Map input to the input model of the use case</li>
<li>Call use case</li>
<li>Map output of the use case back to HTTP</li>
<li>Return HTTP response</li>
</ul>
<p>Create a separate controller for each operation, don't reuse input objects (ie create endpoint/update endpoint probably differ by an id attribute only but that is okay). Consider putting each controller and its input objects into a package and making the input objects private to discourage re-use.</p>
</div></div></div></div></body></html>