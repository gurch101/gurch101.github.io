<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Get your Hands Dirty On Clean Architecture | Gurchet&#x27;s Development Blog</title><meta name="description" content="Get Your Hands Dirty on Clean Architecture Summary"/><link rel="icon" href="/favicon.ico"/><meta name="next-head-count" content="5"/><link rel="preload" href="/_next/static/css/51dd2ece2d2e2902880b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/51dd2ece2d2e2902880b.css" data-n-g=""/><link rel="preload" href="/_next/static/css/da823d5520371b52ce1f.css" as="style"/><link rel="stylesheet" href="/_next/static/css/da823d5520371b52ce1f.css" data-n-p=""/><noscript data-n-css=""></noscript></head><body><div id="__next"><div class="container"><div><h1 class="mb3">Get your Hands Dirty On Clean Architecture</h1><div class="meta"><span>Sat Oct 09 2021</span><span>book summary</span></div><div class="mt25 post"><h3>What's Wrong with Layers</h3>
<p>Traditional app - controllers, domain/service, persistence</p>
<p>Problems:</p>
<ul>
<li>It promotes database-driven design. We should be trying to model behaviour, not state. Also leads to tight coupling between the repository/entities and the service.</li>
<li>It's prone to shortcuts. In a typical layered architecture, you can only access things in the same layer or lower. If you need to access something in a higher layer, we move the thing to the lower layer. IE utils/helpers in repo layer.</li>
<li>It grows hard to test. In simple cases, devs make the controller talk to repo directly - makes test setup difficult. More dependencies = harder test setup. A complex test setup is the first step towards no tests at all because we don't have time for them.</li>
<li>It hides the use cases. Layered architectures don't impose rules on the "width" of domain services making things hard to find/maintain.</li>
<li>It makes parallel work difficult.</li>
</ul>
<h3>Inverting Dependencies</h3>
<p>Single Responsibility Principle - a component should only have one reason to change.</p>
<p>You shouldn't need to change a component if its dependencies change.</p>
<p>Dependency inversion principle - invert the direction of any dependency in our code base.</p>
<p>The domain code shouldn't have dependencies; instead, all depdencies point towards the domain code.</p>
<p><img src="/images/di.png" alt="Dependency Inversion">
<img src="/images/hexarch.png" alt="Hexagonal Architecture"></p>
<h3>Organizing Code</h3>
<p>Traditional package structure is just a nice-looking facade for an unstructured mess of code - classes in one package import classes from other packages that should not be imported.</p>
<div class="remark-highlight"><pre class="language-unknown"><code class="language-unknown">app
    /domain
    /persistence
    /web</code></pre></div>
<p>Organizing by feature - allows enforcing access via package-private visibility for classes. Don't allow broad services (ie use SendMoneyService vs AccountService).</p>
<div class="remark-highlight"><pre class="language-unknown"><code class="language-unknown">app
    /feature1
        /adapter
            /in
                /web
            /out
                /persistence
        /domain
        /application
            &#x26;lt;services go here&#x26;gt;
            /port
                /in
                    &#x26;lt;use cases go here&#x26;gt;
                /out
    /feature2</code></pre></div>
<p><img src="/images/hexarchpackages.png" alt="Package structure"></p>
</div></div></div></div></body></html>