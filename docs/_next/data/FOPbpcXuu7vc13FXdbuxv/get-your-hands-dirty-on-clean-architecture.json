{"pageProps":{"post":{"id":"get-your-hands-dirty-on-clean-architecture","title":"Get your Hands Dirty On Clean Architecture","category":"book summary","description":"Get Your Hands Dirty on Clean Architecture Summary","type":"notes","date":"Sat Oct 09 2021","contentHtml":"<h3>What's Wrong with Layers</h3>\n<p>Traditional app - controllers, domain/service, persistence</p>\n<p>Problems:</p>\n<ul>\n<li>It promotes database-driven design. We should be trying to model behaviour, not state. Also leads to tight coupling between the repository/entities and the service.</li>\n<li>It's prone to shortcuts. In a typical layered architecture, you can only access things in the same layer or lower. If you need to access something in a higher layer, we move the thing to the lower layer. IE utils/helpers in repo layer.</li>\n<li>It grows hard to test. In simple cases, devs make the controller talk to repo directly - makes test setup difficult. More dependencies = harder test setup. A complex test setup is the first step towards no tests at all because we don't have time for them.</li>\n<li>It hides the use cases. Layered architectures don't impose rules on the \"width\" of domain services making things hard to find/maintain.</li>\n<li>It makes parallel work difficult.</li>\n</ul>\n<h3>Inverting Dependencies</h3>\n<p>Single Responsibility Principle - a component should only have one reason to change.</p>\n<p>You shouldn't need to change a component if its dependencies change.</p>\n<p>Dependency inversion principle - invert the direction of any dependency in our code base.</p>\n<p>The domain code shouldn't have dependencies; instead, all depdencies point towards the domain code.</p>\n<p><img src=\"/images/di.png\" alt=\"Dependency Inversion\">\n<img src=\"/images/hexarch.png\" alt=\"Hexagonal Architecture\"></p>\n"}},"__N_SSG":true}