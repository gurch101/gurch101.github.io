{"pageProps":{"post":{"id":"ddd-and-microservices-for-architects","title":"Domain-Driven Design and Microservices for Architects","category":"summary","description":"Udemy course notes","type":"notes","date":"Sat Jun 11 2022","contentHtml":"<p>Monolithic architectures</p>\n<ul>\n<li>large, modular code bases with tight coupling between components</li>\n<li>teams are organized by technology and business</li>\n<li>changes require coordination between teams and span across multiple business functions</li>\n</ul>\n<p>Microservice architectures</p>\n<ul>\n<li>collection of find grained, loosely coupled services built to realize a specific business capability</li>\n<li>interactions are via well-defined contracts over the network</li>\n</ul>\n<p>Business transformation examples:</p>\n<ul>\n<li>microsoft: packaged software to subscription model</li>\n<li>amazon: online bookstore to marketplace</li>\n<li>apple: computers to ipod, iphones, mac, music</li>\n<li>netflix: DVD mail service to streaming service</li>\n</ul>\n<p>Businesses change because of regulatory changes, competitive pressure, new opportunities, and customer demands</p>\n<p>Transformation is not a one-time initiative. Needs to be rapid and continuous.</p>\n<p>Each service is built and operated by a small team (two-pizza team) which evolves independently. Each team focuses on the business capabilities provided by their microservice. Leads to decentralized governance and well-defined business scope.</p>\n<p>Microservice advantages:</p>\n<ul>\n<li>requires minimal coordination with other teams</li>\n<li>regression testing is needed only for the changed service</li>\n<li>independent deployments</li>\n<li>failure in one service will not bring down entire system</li>\n<li>each service can scale independently</li>\n</ul>\n<p>Microservice disadvantages:</p>\n<ul>\n<li>poor network performance</li>\n<li>complexity managing data integrity</li>\n<li>harder to monitor and debug</li>\n</ul>\n<p>Creating a business case:</p>\n<ul>\n<li>quantify the business value</li>\n<li>have a roadmap</li>\n<li>describe requirements for success</li>\n<li>present a PoC</li>\n</ul>\n<h3>Introduction to Domain-Driven Design</h3>\n<p>A domain = sphere of knowledge, influence, or activity. A field or industry in which the business operates. The problem space.</p>\n<p>Each domain consists of sub-domains. Three types: generic, core, supporting</p>\n<p>No one expert know everything about the domain. Multiple domain experts are aligned to sub-domains.</p>\n<p>A domain is made up of vocabulary, entities/relationships, key concepts, and workflow activities.</p>\n<p>Teams central focus should be on the core domain and domain logic.</p>\n<p>Each sub-domain has a different level of complexity that is driven by the business rules, compliance, process/handovers, dynamicity</p>\n<h5>Modeling</h5>\n<p>Think about purpose of model and perspective of shareholders before constructing a model.</p>\n<p>conveys idea to stakeholders and provides a point of reference to create detailed specifications.</p>\n<p>Define common terminology for all domain concepts.</p>\n<p>Define relationships between concepts.</p>\n<p>4 + 1 modeling</p>\n<p>Logical view = functionality provided to end-user/business value</p>\n<p>Process view = workflow/interaction</p>\n<p>Development view = modules/subsystems</p>\n<p>Physical view = servers/db design</p>\n<p>Taken together, these views form scenarios/requirements</p>\n<p>knowledge crunching = convert SME knowledge into structured domain models</p>\n<p>Goal of a software development team is to help the business achieve its business goals, hence the team MUST understand the business model.</p>\n<h5>Business Model Canvas</h5>\n<p>A tool that helps discuss, communicate, design, and understand the organization's business model</p>\n<p>9 areas:\nkey partners - who supplies resources?\nkey activities\nkey resources - what does the value prop need?\nvalue propositions\ncustomer relationships\nchannels\ncustomer segments\ncost structure\nrevenue streams</p>\n<h3>Domain-Driven Design Patterns</h3>\n<p>Generic subdomain: known solutions with best practices exist. No business advantage exists in re-inventing the wheel.</p>\n<p>Core subdomain: the business differentiator which gives the company a competitive advantage. Fast paced and ever evolving.</p>\n<p>Supporting subdomain: no business advantage but core depends on it.</p>\n<p>Known solutions available? Generic\nAdds business value? Core\nCore depends on it? Supporting</p>\n<p>Business should focus on core sub-domain, buy generic sub-domains, and outsource supporting domains.</p>\n<h5>Ubiquitous language</h5>\n<p>A common, evolving, language within each business context that is used by <em>all</em> stakeholders - business and technology experts. Used in code/tests, communication, documentation.</p>\n<h5>Bounded Context</h5>\n<p>Entities in one sub-domain are independent of other sub-domains, even if they share the same language (ie retail banking customer = employer + demographics, credit cards customer = income + credit history, compliance = kyc/fraud).</p>\n<p>Each bounded context has its own ubquitous language and is translated into one or more microservices.</p>\n<p>Discover bounded contexts by drawing boundaries around business functions</p>\n<p>A context map is a visual representation of the systems bounded contexts and the relationships between them</p>\n<ul>\n<li>\n<p>separate ways pattern - each bounded context is completely independent of one another</p>\n</li>\n<li>\n<p>Symmetric relationship - bounded contexts depend on one another.</p>\n<ul>\n<li>Partnership pattern. Teams must coordinate changes.</li>\n<li>Shared kernel pattern - use a shared library which contains shared models. Coordination is only needed on changes on the shared models.</li>\n</ul>\n</li>\n<li>\n<p>asymmetric relationship - one bounded context depends on another.</p>\n<ul>\n<li>customer-supplier pattern. Upstream bounded context fulfills a specific need of the downstream bounded context. Upstream BC adjusts to meet requirements of downstream BC.</li>\n<li>Conformist pattern. Upstream BC exposes models with no regard to ANY douwnstream BC. Downstream BC conforms to models exposed by upstream BC.</li>\n<li>Anti-corruption layer pattern. Downstream BC isolates translation logic in a separate layer.</li>\n</ul>\n</li>\n<li>\n<p>one-to-many relationships.</p>\n<ul>\n<li>Open host service. Upstream provider offers common services to other BC's. Published language is used by all downstream BCs.</li>\n</ul>\n</li>\n</ul>\n<h5>Entity Object</h5>\n<p>A business object that encapsulates attributes and well-defined domain logic (business rules, validations, calculations) that is within a bounded context. Entities are persisted in long term storage and have IDs to uniquely identify them. IE accounts, orders, etc</p>\n<h5>Value Object</h5>\n<p>An immutable object that doesnt map directly into the core concepts of the bounded context. Data types the encapsulate validation/format for non core concepts - IE EmailAddress. Do not have IDs - comparison requires full attribute-level comparison. Not persisted as an independent object but may be part of an entity.</p>\n<h5>Aggregate</h5>\n<p>An agregate object is a cluster of entities and value objects that are viewed as a unified whole from the domain concepts and data perspective. Has a unique identity. Example: Account is aggregate route, has transactions.</p>\n<p>The aggregate provides functions to operate on the inner objects. Do not interact with inner objects directly.</p>\n<p>Inner objects are only meaningful in the context of the root.</p>\n<h5>Repository</h5>\n<p>A repository object acts as a collection of aggregate objects in memory. It hides the storage level details of the aggregate.</p>\n<p>One repo per aggregate. Persistence operations are atomic.</p>\n<p>Used to keep the domain model indpeendent of the storage layer.</p>\n<h5>Anemic vs Rich Models</h5>\n<p>anemic model - a domain model composed of entities that do not exhibit operations applicable to the domain concepts</p>\n<p>rich model - business model is implement as an inherent part of the entity</p>\n<p>Anemic models are acceptable for apps with minimal business logic, simple CRUD, or shared logic that doesn't belong in a single model entity.</p>\n<h5>Domain Service</h5>\n<p>Implements domain functionality that may not be modeled as a behavior in any domain entity or value object. Does not maintain state between calls. Should be highly cohesive and do only one thing. May call other domain services.</p>\n<h5>Application Service</h5>\n<p>Does not implement domain functionality but depends on other domain objects/services. Stateless, define an external interface, exposed over network. Orchestrates execution of domain logic and transforms into response object. Can be used to consolidate results from several domain objects.</p>\n<h5>Infrastructure Service</h5>\n<p>A service that interacts with an external resource to address a concern that is not part of the primary problem domain.\nExamples - logging, notifications, persistence, external APIs. No dependency on any domain object.</p>\n<h3>TODO</h3>\n<p>look for practical DDD examples with persistence. How to do db-backed validation in an entity object?</p>\n"}},"__N_SSG":true}