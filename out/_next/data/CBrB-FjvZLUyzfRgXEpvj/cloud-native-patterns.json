{"pageProps":{"post":{"id":"cloud-native-patterns","title":"Cloud Native Patterns","category":"book summary","description":"Cloud Native Patterns Summary","type":"notes","date":"Sat Oct 02 2021","contentHtml":"<p>Cloud = where it runs; Cloud-native = how it runs</p>\n<p>Modern apps need rapid iteration, fast releases, zero downtime and an increase in the volume and variety of devices that connect to it.</p>\n<p>Cloud-native applications remain stable even when the infra they're running on is constantly changing/failing</p>\n<h3>Chapter 2: Running Cloud-Native Applications in Production</h3>\n<p>In most orgs, getting software deployed to prod is challenging - process designed to reduce risk and improve efficiency has the opposite effect</p>\n<p>inconsistencies in artifacts, configuration, and environments lead to system instability</p>\n<p>goal should be easy and frequent releases into production</p>\n<p>continuous delivery = the newest possible version of the software is deployable at any time (trunk is always deployable)</p>\n<ul>\n<li>advantages: can deploy at any time (first mover advantage), allows you to gather feedback early. If you miss dates,\nyou can release less features</li>\n</ul>\n<p>traditional delivery = SDLC is front-loaded with development, followed by extensive testing and packaging</p>\n<ul>\n<li>disadvantages: if you miss dates, testing is compressed (at the expense of quality) or you push dates</li>\n</ul>\n<p>Before: tested extensively before going to production and were left scrambling on go-live.\nAfter: Plan for failure and intentionally create a retreat path to make failures non-events. Monitor for crashes, latency changes, changes in click-through rates, etc.</p>\n"}},"__N_SSG":true}