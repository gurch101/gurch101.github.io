{"pageProps":{"post":{"id":"cloud-native-patterns","title":"Cloud Native Patterns","category":"book summary","description":"Cloud Native Patterns Summary","type":"notes","date":"Sat Oct 02 2021","contentHtml":"<p>Cloud = where it runs; Cloud-native = how it runs</p>\n<p>Modern apps need rapid iteration, fast releases, zero downtime and an increase in the volume and variety of devices that connect to it.</p>\n<p>Cloud-native applications remain stable even when the infra they're running on is constantly changing/failing</p>\n<h3>Chapter 2: Running Cloud-Native Applications in Production</h3>\n<p>In most orgs, getting software deployed to prod is challenging - process designed to reduce risk and improve efficiency has the opposite effect</p>\n<p>inconsistencies in artifacts, configuration, and environments lead to system instability</p>\n<p>goal should be easy and frequent releases into production</p>\n<p>continuous delivery = the newest possible version of the software is deployable at any time (trunk is always deployable)</p>\n<ul>\n<li>advantages: can deploy at any time (first mover advantage), allows you to gather feedback early. If you miss dates,\nyou can release less features</li>\n</ul>\n<p>traditional delivery = SDLC is front-loaded with development, followed by extensive testing and packaging</p>\n<ul>\n<li>disadvantages: if you miss dates, testing is compressed (at the expense of quality) or you push dates</li>\n</ul>\n<p>Before: tested extensively before going to production and were left scrambling on go-live.</p>\n<p>After: Plan for failure and intentionally create a retreat path to make failures non-events. Monitor for crashes, latency changes, changes in click-through rates, etc.</p>\n<h3>Chapter 3: The Platform for Cloud-Native Software</h3>\n<p>AWS uses commodity hardware to offer services at a lower price but with a higher rate of failure. Exposes primitives as a service.</p>\n<p>Google app engine doesnt provide raw access to resources.</p>\n<p>For cloud-native apps, operators are interested in the application and <em>not</em> the hosts the app is running on/directories involved</p>\n<p>The popularity of containers was driven by the need to support cloud-native applications. Multiple containers run on a single host sharing the host's operating system.</p>\n<p>The platform creates app instances, monitors application health, distributes app instances across the infrastructure, assigns IP addresses to the containers, dynamically routes to app instances, and injects configuration</p>\n<p>challenges of highly distributed architectures:</p>\n<ul>\n<li>coordinating configuration changes</li>\n<li>tracing/monitoring execution flows</li>\n<li>retry logic - circuit breakers prevent inadvertent internal DDoS</li>\n<li>service discovery - each component needs to know URLs/IPs of all components it calls</li>\n<li>rolling upgrades</li>\n</ul>\n<p>each team is responsible for deployment, configuration, monitoring, scaling, and upgrading its products</p>\n<h3>Chapter 4: Event-Driven Microservices</h3>\n<p>Request-response = procedural/top-down - service request waits for responses from each dependent service and does some sort of aggregation to respond. Aggregation occurs in response to request.</p>\n<p>Event-driven = fire and forget - code execution has an effect and the outcome may cause other things to happen but the entity that triggered the execution doesnt expect a response. Aggregation occurs whenever data in the system changes - its asynchronous.</p>\n<p>Even-driven is less coupled and does not depend on other systems working correctly. Dependent services execute events to the aggregate service which maintains its own data store. Each service is independent of the other.</p>\n<p>Command Query Responsibility Segregation (CQRS) - separates write logic (commands) rom read logic (queries). Splitting controllers by read/write allows for different models on read/write.</p>\n<p>Events need message queues (RabbitMQ/Kafka) to store events through network partitions and handle downtimes in services</p>\n<p>https://github.com/cdavisafc/cloudnative-abundantsunshine</p>\n<h3>Chapter 5: App Redundancy: Scale-Out and Statelessness</h3>\n<p>Core tenant of cloud-native software is to have redundancy to avoid single points of failure. Apps should always have multiple instances deployed.</p>\n<p>Multiple instances should behave like a single logical entity.</p>\n<p>Multiple instances allow for flexible horizontal scaling, high availability, reliability, and operational efficiency.</p>\n<p>Kubernetes is a platform for running applications that includes capabilities that allow you to deploy, monitor, and scale your apps. Apps must be containerized to run in kubernetes.</p>\n<p>Instances must be stateless to allow for redundant deployment.</p>\n<p>CAP theorem - only two attributes of consistency, availability, and partition tolerance can be maintained.</p>\n"}},"__N_SSG":true}