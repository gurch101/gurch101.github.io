{"pageProps":{"post":{"id":"cloud-native-patterns","title":"Cloud Native Patterns","category":"book summary","description":"Cloud Native Patterns Summary","type":"notes","date":"Sat Oct 02 2021","contentHtml":"<p>Cloud = where it runs; Cloud-native = how it runs</p>\n<p>Modern apps need rapid iteration, fast releases, zero downtime and an increase in the volume and variety of devices that connect to it.</p>\n<p>Cloud-native applications remain stable even when the infra they're running on is constantly changing/failing</p>\n<h3>Chapter 2: Running Cloud-Native Applications in Production</h3>\n<p>In most orgs, getting software deployed to prod is challenging - process designed to reduce risk and improve efficiency has the opposite effect</p>\n<p>inconsistencies in artifacts, configuration, and environments lead to system instability</p>\n<p>goal should be easy and frequent releases into production</p>\n<p>continuous delivery = the newest possible version of the software is deployable at any time (trunk is always deployable)</p>\n<ul>\n<li>advantages: can deploy at any time (first mover advantage), allows you to gather feedback early. If you miss dates,\nyou can release less features</li>\n</ul>\n<p>traditional delivery = SDLC is front-loaded with development, followed by extensive testing and packaging</p>\n<ul>\n<li>disadvantages: if you miss dates, testing is compressed (at the expense of quality) or you push dates</li>\n</ul>\n<p>Before: tested extensively before going to production and were left scrambling on go-live.</p>\n<p>After: Plan for failure and intentionally create a retreat path to make failures non-events. Monitor for crashes, latency changes, changes in click-through rates, etc.</p>\n<h3>Chapter 3: The Platform for Cloud-Native Software</h3>\n<p>AWS uses commodity hardware to offer services at a lower price but with a higher rate of failure. Exposes primitives as a service.</p>\n<p>Google app engine doesnt provide raw access to resources.</p>\n<p>For cloud-native apps, operators are interested in the application and <em>not</em> the hosts the app is running on/directories involved</p>\n<p>The popularity of containers was driven by the need to support cloud-native applications. Multiple containers run on a single host sharing the host's operating system.</p>\n<p>The platform creates app instances, monitors application health, distributes app instances across the infrastructure, assigns IP addresses to the containers, dynamically routes to app instances, and injects configuration</p>\n<p>challenges of highly distributed architectures:</p>\n<ul>\n<li>coordinating configuration changes</li>\n<li>tracing/monitoring execution flows</li>\n<li>retry logic - circuit breakers prevent inadvertent internal DDoS</li>\n<li>service discovery - each component needs to know URLs/IPs of all components it calls</li>\n<li>rolling upgrades</li>\n</ul>\n<p>each team is responsible for deployment, configuration, monitoring, scaling, and upgrading its products</p>\n<h3>Chapter 4: Event-Driven Microservices</h3>\n"}},"__N_SSG":true}